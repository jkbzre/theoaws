import { useEffect, useMemo, useState } from 'react';

const TRANSPARENT_PLACEHOLDER = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==';

const blurDataUrlCache = new Map();

const isValidDataUrlImage = (value) => typeof value === 'string' && value.startsWith('data:image');

/**
 * OptimizedImage - A component for instantly displaying images with blur placeholder
 * 
 * Features:
 * - Blur placeholder while loading (instant visual feedback)
 * - WebP with fallback to JPG/PNG
 * - Responsive images with srcSet
 * - Lazy loading for below-the-fold images
 * - Proper width/height to prevent layout shift
 * - Modern loading strategies
 * 
 * @param {string} src - Main image source URL
 * @param {string} alt - Alt text for accessibility
 * @param {string} className - CSS classes
 * @param {boolean} priority - If true, preload this image (for above-the-fold)
 * @param {string} blurDataURL - Optional base64 blur placeholder
 * @param {string} width - Image width (helps prevent layout shift)
 * @param {string} height - Image height (helps prevent layout shift)
 * @param {string} srcSet - Optional responsive image srcSet
 * @param {string} sizes - Optional sizes attribute for responsive images
 */
const OptimizedImage = ({ 
    src, 
    alt = '', 
    className = '', 
    priority = false,
    blurDataURL,
    width,
    height,
    srcSet,
    sizes,
    ...props 
}) => {
    const [isLoaded, setIsLoaded] = useState(false);
    // Normalize to HTTPS to avoid mixed-content blocking
    const normalizeToHttps = (url) => (typeof url === 'string' ? url.replace(/^http:\/\//i, 'https://') : url);
    const normalizedSrc = normalizeToHttps(src);
    const initialBlur = isValidDataUrlImage(blurDataURL) ? blurDataURL : TRANSPARENT_PLACEHOLDER;
    const [currentBlurSrc, setCurrentBlurSrc] = useState(initialBlur);

    // Auto-detect WebP version if available
    const webpSrc = typeof normalizedSrc === 'string' ? normalizedSrc.replace(/\.(jpg|jpeg|png)$/i, '.webp') : '';
    
    // Auto-generate srcSet from src if not provided
    const autoSrcSet = useMemo(() => {
        if (srcSet) return srcSet;
        if (typeof normalizedSrc !== 'string') return undefined;
        if (!normalizedSrc.match(/\.(jpg|jpeg|png)$/i)) return undefined;
        return `${normalizedSrc.replace(/\.(jpg|jpeg|png)$/i, '.400.$1')} 400w, ${normalizedSrc.replace(/\.(jpg|jpeg|png)$/i, '.800.$1')} 800w, ${normalizedSrc.replace(/\.(jpg|jpeg|png)$/i, '.1200.$1')} 1200w`;
    }, [normalizedSrc, srcSet]);

    // Fetch blur placeholder if not provided (expects {src}.base64.txt generated by optimizer)
    useEffect(() => {
        const controller = new AbortController();

        if (isValidDataUrlImage(blurDataURL)) {
            setCurrentBlurSrc(blurDataURL);
            return () => controller.abort();
        }

        if (typeof normalizedSrc !== 'string' || normalizedSrc.length === 0) {
            setCurrentBlurSrc(TRANSPARENT_PLACEHOLDER);
            return () => controller.abort();
        }

        const placeholderUrl = `${normalizedSrc}.base64.txt`;

        const cached = blurDataUrlCache.get(placeholderUrl);
        if (isValidDataUrlImage(cached)) {
            setCurrentBlurSrc(cached);
            return () => controller.abort();
        }

        fetch(placeholderUrl, { cache: 'force-cache', signal: controller.signal })
            .then((res) => (res.ok ? res.text() : null))
            .then((data) => {
                if (!isValidDataUrlImage(data)) return;
                blurDataUrlCache.set(placeholderUrl, data);
                setCurrentBlurSrc(data);
            })
            .catch(() => {
                // Silent fallback to transparent placeholder
            });

        return () => controller.abort();
    }, [blurDataURL, normalizedSrc]);

    const wrapperStyle = {
        position: 'relative',
        display: 'block',
        lineHeight: 0,
    };

    const placeholderStyle = {
        position: 'absolute',
        inset: 0,
        width: '100%',
        height: '100%',
        objectFit: 'cover',
        transition: 'opacity 200ms ease-out, filter 200ms ease-out',
        opacity: isLoaded ? 0 : 1,
        filter: 'blur(12px)',
        transform: 'scale(1.02)',
    };

    const realImageStyle = {
        width: '100%',
        height: '100%',
        objectFit: 'cover',
        transition: 'opacity 200ms ease-out',
        opacity: isLoaded ? 1 : 0,
    };

    if (typeof normalizedSrc !== 'string' || normalizedSrc.length === 0) {
        return (
            <img
                src={currentBlurSrc || TRANSPARENT_PLACEHOLDER}
                alt={alt}
                className={className}
                width={width}
                height={height}
                {...props}
            />
        );
    }

    return (
        <span style={wrapperStyle}>
            <img
                src={currentBlurSrc || TRANSPARENT_PLACEHOLDER}
                alt=""
                aria-hidden="true"
                style={placeholderStyle}
                className={className}
                width={width}
                height={height}
                decoding="async"
            />

            <picture>
                <source
                    type="image/webp"
                    srcSet={autoSrcSet ? autoSrcSet.replace(/\.(jpg|jpeg|png)/gi, '.webp') : webpSrc}
                    sizes={sizes || '(max-width: 600px) 400px, (max-width: 1200px) 800px, 1200px'}
                />
                <img
                    src={normalizedSrc}
                    srcSet={autoSrcSet}
                    sizes={sizes || '(max-width: 600px) 400px, (max-width: 1200px) 800px, 1200px'}
                    alt={alt}
                    className={className}
                    loading={priority ? 'eager' : 'lazy'}
                    decoding={priority ? 'sync' : 'async'}
                    fetchPriority={priority ? 'high' : 'auto'}
                    style={realImageStyle}
                    width={width}
                    height={height}
                    onLoad={() => setIsLoaded(true)}
                    onError={() => setIsLoaded(true)}
                    {...props}
                />
            </picture>
        </span>
    );
};

export default OptimizedImage;
